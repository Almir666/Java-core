package RegEx;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

// шаблон создания регулярного выражения:
// Pattern myPattern = Pattern.compile("REGEX");
// Matcher myMatcher = myPattern.matcher("myString");

// Производительность с классами Pattern и Matcher выше чем если работать с методами String

// abcd - соответствует последовательности указаных символов
// [abc] - соответствует любому символу из квадратныъ скобок
// [a-z] - рендж латинских символов с учетом регистра
// [0-9] - так же можно передать диапозон из цифр
// [a-d5-10] можно задать диапозон сразу из символов и цифр
// [^a-d] - знак "^" это отрицание, символ подойдет для выражения если он не из заданого в скобках диапозона
// [abc(d|7)] - знак " | " обозначает "или" то есть в данной строке ищем abcd или abc7
// . - любой символ
// ? - 0 или 1 количеств повторений
// * - 0 или более количеств повторений
// + - 1 или более количеств повторений
// ^abc - соответствие выражению в начале строки
// abc$ - соответствие выражению в конце строки
// \d - одна цифра
// \D - одна не цифра
// \w - цифра символ или "_"
// \W - НЕ цифра символ или "_"
// {n} - символы в количестве "n". Например: \\w{4} - найдется последовательность из любых 4х символов
// {n,m} - диапозон от n до m. {n,} если после запятой ничего нет значит до бесконечности
// \A - соответствует выражению в начале строки
// \z - соответствует выражению в конце строки
public class RegexEx1 {
    public static void main(String[] args) {
        // String s1 = "ABCD ABCDF ABCDFG ABCABCDEFG";
        String s2 = "ACB JFJKNJ DABFJNW FDB";
        Pattern myPattern = Pattern.compile("[ABC]");
        Matcher myMatcher = myPattern.matcher(s2);

        // find() возвращает true столько раз сколько есть вхождений подстроки 
        while (myMatcher.find()) {
            // group() возвращает подстроку которая совпала с регулярным выражением
            System.out.println("Position - " + myMatcher.start() + " : " + myMatcher.group());
        }
    }
}
