package Test;

import java.util.Arrays;

public class LeetCode {
    // <<ARRAYS>>

    // task 1
    public static int[] duplicateZeros(int [] arr) {
        // Идем с конца до начала
        for(int i = arr.length - 1; i >=0 ; i--) {
            if(arr[i] == 0) {
                // Если текущий элемент равен 0 то запускаем цикл который сдвигает вправо все элементы начиная от текущего
                for(int j = arr.length -1; j > i; j--) {
                    arr[j] = arr[j-1];
                }
            }
        }
        return arr;
    }    

    // task 2
    public static int[] mergeSortedArrays(int[] arr1, int[] arr2, int m, int n) {
        // в условии длина arr1 должна быть m + n, где m это те эелементы которые доложны быть объеденены,
        // а последние n элементов равны 0 и игнорируются. Длина arr2 = n
        // массивы уже отсортированны
        // пропускаем первые m элементов и запускаем цикл с точки где наинаются n элементы, это m

        
    // int[] nums1 = {1,2,3,0,0,0};
    // int[] nums2 = {2,5,6};
    // int m = 3;
    // int n = 3;
        for(int i = m; i < m + n; i++){
            // просто дозаполняем первый массив меняя нули на элементы второго массива, так как i повышается то сначла будет i-m = 0 далее i-m=1 ...
            // в итоге все элементы из второго массива скопируются в конец первого начиная с нулей
            arr1[i] = arr2[i-m];
        }
        // далее просто сортируем
        Arrays.sort(arr1);
        return arr1;
    }

    // task 3
    public static int[] deleteNum(int[] arr, int num) {
        int count = 0;
        for(int i=0; i<arr.length; i++) {
            if(arr[i] != num) {
                arr[count++] = arr[i];
            }
        }
        return arr;
    }

    //task 4
    public static int[] setArray(int[] arr) {
        int count = 0;
        // Пробегаемся по массиву, если указатель не дошел до конца и текущий и следующий элемент равны то пропускаем итерацию
        for(int i = 0; i < arr.length; i++) {
            if (i < arr.length - 1 && arr[i] == arr[i+1]) {
                continue;
            }
            // если итерация пошла дальше то увеличиваем каунт и перезаписваем элементы
            arr[count] = arr[i];
            count++;
        }
        return arr;
    } 

    // task 5
    public static boolean checkNums(int[] arr) {
        // идем по всему массиву от начала
        for (int i=0; i<arr.length; i++) {
            // для каждого элемента идме по всему массиву проверяя
            for(int j=0; j<arr.length; j++) {
                // проверка условия, я вляется ли одно число квадратом другого, если да то true
                if(i!=j &&  (arr[i] == 2*arr[j] || arr[i]*2 == arr[j])) {
                    return true;
                }
            }
        }
        return false;
    }

    // task 6
    public static boolean isMountain(int[] arr) {
        // как решаем
        // в первую очередь проверка: если массив менее чем из трех символов то он по опредлению не может быть горным
        if(arr.length < 3) {
            return false;
        }
        // Берем i и j как точка от которой идем с начала и точка от которой идем с конца, и смотрим идет ли рост к вершине неприрывно(он должен так идти)
        int i = 0;
        int j = arr.length - 1;
        // бежим от начала, если последующиц элемент больше то i++ и движемся дальше
        while ((i + 1) < (arr.length -1) && arr[i] < arr[i+1]) {
            i++;
        }
        // тоже самое только в обратном порядке
        while (j > 0 && arr[j] < arr[j-1]) {
            j--;
        }
        // проверяем не является ли край самой высокой точкой
        if (i == 0 && j == arr.length -1) return false;
        // если массив горный то эти точки будут иметь одинаковое значение(сам считал)
        return i == j;
    }

    // task 7
    public static int[] replaceElement(int[] arr) {
        // Заводим переменную которая будет содержать текущий максимальный элемент
        int maxCurrent = -1;

        // Идем по массиву в обратном порядке, если текущий элемент больше максимального, то меняем максимальный и текущий элементы местами
        // делаю это через временную переменную temp
        for(int i = arr.length - 1; i >= 0; i--) {
            if(arr[i] > maxCurrent) {
                int temp = maxCurrent;
                maxCurrent = arr[i];
                arr[i] = temp;
            }
        // Если же максималный больше текущего то меняем значение теекущего на макисмальное
            else {
                arr[i] = maxCurrent;
            }
        }
        return arr;
    }

    // task 8
    public static int[] zeroToEnd(int[] arr) {
        // пробегаемся по всему массиву с самого начала
        for (int i = 0; i < arr.length; i++) {
            // если текущий элемент не равен 0 то пропускаем итерацию
            if (arr[i] != 0) continue;
            // если 0 то создаем новый указатель на 1 больше чем i и проегаемся в новом цикле начиная с j
            // если текущий элемент не 0 то поменяем его местами с предыдущим элементом который был 0 и закончим внутренний цикл, вернемся к внешнему
            else {
                int j = i+1;
                for (; j < arr.length; j++) {
                    if (arr[j] != 0) {
                        arr[i] = arr[j];
                        arr[j] = 0;
                        break;
                    }
                }
                // во внешнем цикле каждый раз проверяем указатель j если он сравняется с длиной массива то заканчиваем цикл
                if (j == arr.length) {
                    break;
                }
            }
        }
        return arr;  
    }

    // task 9
    public static int[] evenOdd(int[] arr) {
        // пробегаемся по массиву
        for(int i = 0; i < arr.length; i++) {
            // если попалось нечетное число, то для него начинаем новый цикл, что бы найти ближайший четный элемент
            if(arr[i] % 2 != 0) {
                for(int j = i + 1; j < arr.length; j++) {
                    // если нашли этот элемент то просто меняем их местами
                    if(arr[j] % 2 == 0) {
                        int t = arr[i];
                        arr[i] = arr[j];
                        arr[j] = t;
                    }
                }
            }    
        }
        return arr;
    }

    // task 10
    public static int notVal(int[] arr, int val) {
        int k = 0;
        for(int i = 0; i < arr.length; i++) {
            if (arr[i] != val) {
                arr[k++] = arr[i];              
            }
        }
        System.out.println(Arrays.toString(arr));
        return k;
    }

    // task 11
    public static int notMatch(int[] arr) {
        int result = 0;
        int[] temp = arr.clone();
        // int[] temp = new int[arr.length];
        // for(int i = 0; i < arr.length; i++) {
        //     temp[i] = arr[i];
        // }
        Arrays.sort(temp);
        for(int j = 0; j < arr.length; j++) {
            if(temp[j] != arr[j]) result++;
        }
        return result; 
    }



    public static void main(String[] args) {
    // <<ARRAYS>>

    // Ex.1------------------------------------------------------------------------------------------------------------------
    // Duplicate Zeros
    // Продублируйте каждое вхождение 0 сдвигая оставшиеся числа вправо    
    // Числа выходящие за пределы массива затираются
    int[] arr = {1,0,2,3,0,4,5,0};       
    duplicateZeros(arr);
    // System.out.println(Arrays.toString(arr));


    // Ex.2------------------------------------------------------------------------------------------------------------------
    // Merge sorted arrays
    // объедините nums1 и nums2, в один отсортированный в неубывающем порядке массив
    // конечный массив должен храниться в nums1, длина nums1 m + n, где m это те эелементы которые доложны быть объеденены,
    // а последние n элементов равны 0 и игнорируются. Длина nums2 = n

    int[] nums1 = {1,2,3,0,0,0};
    int[] nums2 = {2,5,6};
    int m = 3;
    int n = 3;
    mergeSortedArrays(nums1, nums2, m, n);
    // System.out.println(Arrays.toString(nums1));


    // Ex.3------------------------------------------------------------------------------------------------------------------
    // Удалите все вхождения val в nums in-place. Порядок элементов может быть 
    // изменен. Затем верните количество элементов в nums, которые не равны val.
    // Если считать, что количество элементов в nums, не равных val, равно k, то для его получения необходимо выполнить следующие действия:
    // Изменить массив nums так, чтобы первые k элементов nums содержали элементы, не равные val. Остальные элементы nums не важны, как и размер nums.
    // Верните k.

    int[] arr2 = {3,2,2,3};
    int val = 3;
    deleteNum(arr2, val);
    // System.out.println(Arrays.toString(arr2));


    // Ex.4------------------------------------------------------------------------------------------------------------------
    // Из целочисленного массива nums, отсортированного в неубывающем порядке, удалите дубликаты на месте так, чтобы каждый уникальный элемент встречался только один раз. 
    // Относительный порядок элементов должен остаться прежним. Затем верните количество уникальных элементов в nums.

    // Если считать, что количество уникальных элементов в nums равно k, то для его получения необходимо выполнить следующие действия:

    // Изменить массив nums таким образом, чтобы первые k элементов nums содержали уникальные элементы в том порядке, в котором они присутствовали в nums изначально. 
    // Остальные элементы nums не важны, как и размер nums.
    // Верните k.

    int[] arr3 = {1,1,2};
    setArray(arr3); 
    // System.out.println(Arrays.toString(arr3));


    // Ex.5------------------------------------------------------------------------------------------------------------------
    // Дан массив целых чисел, проверьте, существуют ли два целых числа N и M такие, что N является удвоением M (т.е. N = 2 * M).

    int[] arr1 = {-2,0,10,-19,4,6,-8};
    // System.out.println(checkNums(arr1));


    // Ex.6------------------------------------------------------------------------------------------------------------------
    // Задав массив целых чисел arr, верните true тогда и только тогда, когда он является допустимым горным массивом.

    int[] arrm1 = {2,1};
    int[] arrm2 = {3,5,6,3,1};
    int[] arrm3 = {0,5,3,2,1,0};
    int[] arrm4 = {3,7,6,4,3,0,1,0};

    // System.out.println(isMountain(arrm3));



    // Ex.7------------------------------------------------------------------------------------------------------------------
    // In-Place Array Operations Introduction
    // "in Place" это работа с непосредственно самим массивом а не его копией

    // Replace Elements with Greatest Element on Right Side
    // Задав массив arr, замените каждый элемент этого массива наибольшим элементом среди элементов справа от него, 
    // а последний элемент замените на -1.
    // После этого верните массив.

    int[] arr7 = {17,18,5,4,6,1};
    replaceElement(arr7);
    // System.out.println(Arrays.toString(arr7));


    // Ex.8------------------------------------------------------------------------------------------------------------------
    // Задав целочисленный массив nums, переместите все 0 в его конец, сохранив относительный порядок ненулевых элементов.
    // Обратите внимание, что вы должны сделать это на месте, не создавая копию массива.

    int[] arr8 = {0,1,0,3,12};
    zeroToEnd(arr8);
    // System.out.println(Arrays.toString(arr8));


    // Ex.9------------------------------------------------------------------------------------------------------------------
    // Переместите все четные числа в начало массива, а затем все нечетные.
    // Верните любой массив, удовлетворяющий этому условию.

    int[] arr9 = {3,1,2,4};    
    evenOdd(arr9);
    // System.out.println(Arrays.toString(arr9));    


    // Ex.10-----------------------------------------------------------------------------------------------------------------
    // Удалите все вхождения val в nums[] in-place. Порядок элементов может быть изменен. 
    // Затем верните количество элементов в nums, которые не равны val.
    // Если считать, что количество элементов в nums, не равных val, равно k, то для его получения необходимо выполнить следующие действия:

    // Изменить массив nums так, чтобы первые k элементов nums содержали элементы, не равные val. Остальные элементы nums не важны, как и размер nums.
    // Верните k.

    int[] arr10 = {0,1,2,2,3,0,4,2};
    int val1 = 2;
    // int res10 = notVal(arr10, val1);    
    // System.out.println(res10);    


    // Ex.11-----------------------------------------------------------------------------------------------------------------
    // В одной школе ежегодно фотографируют всех учеников. Учеников просят встать в одну шеренгу в неубывающем порядке по росту. 
    // Пусть этот порядок представлен целочисленным массивом expected, где expected[i] - ожидаемый рост i-го ученика в очереди.
    // Вам дан целочисленный массив heights, представляющий текущий порядок, в котором стоят студенты. 
    // Каждый heights[i] - это высота i-го студента в очереди (с индексом 0).
    // Верните количество несоответствий ожидаемого и действительного порядка в массиве
    
    int[] arr11 = {1,1,4,2,1,3};
    int res11 = notMatch(arr11);    
    // System.out.println(res11);    

    
    // Ex.12-----------------------------------------------------------------------------------------------------------------
    // Верните третье максимальное число в массиве. Если третьего максимального числа не существует, верните максимальное число.

    int[] arr12 = {3,2,1};
        int max3 = 0;
        int max2 = 0;
        int max1 = 0;
        for(int i = 0; i < arr12.length; i++) {
            if(arr12[i] > max1 ) {
                max1 = arr12[i];
            }
        }
        
        System.out.println(max1);
    }
}

